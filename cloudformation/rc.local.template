#!/bin/bash

main () {
  DEBIAN_FRONTEND=noninteractive apt-get -y update
  DEBIAN_FRONTEND=noninteractive apt-get -y install awscli

  REGION=$(curl -s http://169.254.169.254/latest/meta-data/placement/region)
  DB_VOLUME_ID=$(get_ssm_parameter "DatabaseVolumeId")
  GIT_REPOSITORY=$(get_ssm_parameter "GitRepository")
  GIT_BRANCH=$(get_ssm_parameter "GitBranch")

  GIT_REPOSITORY_PATH=/home/ubuntu/rocket-analytics
  COMPOSE_FILE="${GIT_REPOSITORY_PATH}/docker-compose.yml"
  COMPOSE_FILE_PROD="${GIT_REPOSITORY_PATH}/docker-compose-prod.yml"
  ENV_FILE="${GIT_REPOSITORY_PATH}/.env"

  # Install and start the application
  install_application
  docker compose -f $COMPOSE_FILE -f $COMPOSE_FILE_PROD up -d --no-build

  # This script needs to be executed only once when server is created
  rm $0
}

install_docker () {
  DEBIAN_FRONTEND=noninteractive apt-get -y update
  DEBIAN_FRONTEND=noninteractive apt-get -y install \
    ca-certificates \
    curl \
    gnupg

  install -m 0755 -d /etc/apt/keyrings
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \
    gpg --dearmor -o /etc/apt/keyrings/docker.gpg

  echo \
    "deb [arch=$(dpkg --print-architecture)" \
    "signed-by=/etc/apt/keyrings/docker.gpg]" \
    "https://download.docker.com/linux/ubuntu" \
    "$(. /etc/os-release && echo $VERSION_CODENAME) stable" | \
    tee /etc/apt/sources.list.d/docker.list > /dev/null

  DEBIAN_FRONTEND=noninteractive apt-get -y update
  DEBIAN_FRONTEND=noninteractive apt-get -y install \
    docker-ce \
    docker-ce-cli \
    containerd.io \
    docker-buildx-plugin \
    docker-compose-plugin
}

install_application () {
  # Install software packages
  DEBIAN_FRONTEND=noninteractive apt-get -y update
  DEBIAN_FRONTEND=noninteractive apt-get -y install git
  install_docker

  # Clone git repository to get Docker Compose file
  git clone $GIT_REPOSITORY $GIT_REPOSITORY_PATH
  git -C $GIT_REPOSITORY_PATH checkout $GIT_BRANCH

  # Fetch environment variables for Docker Compose
  POSTGRES_USERNAME=$(aws ssm get-parameter --name 'PostgresUsername' \
    --region $REGION --query 'Parameter.Value' --output text)
  POSTGRES_PASSWORD=$(aws ssm get-parameter --name 'PostgresPassword' \
    --region $REGION --query 'Parameter.Value' --output text)
  POSTGRES_DATABASE=$(aws ssm get-parameter --name 'PostgresDatabase' \
    --region $REGION --query 'Parameter.Value' --output text)
  DOCKER_REGISTRY=$(aws ssm get-parameter --name 'DockerRegistry' \
    --region $REGION --query 'Parameter.Value' --output text)

  # Create and populate '.env' file for Docker Compose
  touch $ENV_FILE && chmod 600 $ENV_FILE
  echo "PSQL_USER=$POSTGRES_USERNAME" | tee -a $ENV_FILE
  echo "PSQL_PWD=$POSTGRES_PASSWORD" | tee -a $ENV_FILE
  echo "PSQL_DB=$POSTGRES_DATABASE" | tee -a $ENV_FILE
  echo "DOCKER_REGISTRY=$DOCKER_REGISTRY" | tee -a $ENV_FILE
  echo "AWS_REGION=$REGION" | tee -a $ENV_FILE

  mount_db_volume

  # Pull Docker images
  aws ecr get-login-password --region $REGION | \
    docker login --username AWS --password-stdin $DOCKER_REGISTRY
  docker compose -f $COMPOSE_FILE pull
}

get_db_volume_name () {
  id_without_hyphen=$(echo "$DB_VOLUME_ID" | tr -d "-")
  lsblk -p -o NAME,SERIAL | awk -v id=$id_without_hyphen '$2 == id {print $1}'
}

# $1: Parameter name
get_ssm_parameter () {
  echo $(aws ssm get-parameter --name $1 --region $REGION \
    --query 'Parameter.Value' --output text)
}

db_volume_is_formatted () {
  filesystem=$(lsblk -p -o NAME,FSTYPE | \
    awk -v name=$(get_db_volume_name) '$1 == name {print $2}')
  if [ "$filesystem" = "xfs" ]; then
    true
  else
    false
  fi
}

mount_db_volume () {
  if db_volume_is_formatted; then
    echo "Database EBS volume ($(get_db_volume_name)) has already been" \
      "formatted."
  else
    echo "Database EBS volume ($(get_db_volume_name)) is not formatted," \
      "formatting to XFS."
    mkfs -t xfs $(get_db_volume_name)
  fi
  mkdir /data
  mount $(get_db_volume_name) /data
}

main
