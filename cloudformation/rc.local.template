#!/bin/bash

set -Eeuxo pipefail

main () {
  DEBIAN_FRONTEND=noninteractive apt-get -y update
  DEBIAN_FRONTEND=noninteractive apt-get -y install awscli

  REGION=$(curl -s http://169.254.169.254/latest/meta-data/placement/region)
  DB_VOLUME_ID=$(get_ssm_parameter "DatabaseVolumeId")
  GIT_REPOSITORY=$(get_ssm_parameter "GitRepository")
  GIT_BRANCH=$(get_ssm_parameter "GitBranch")
  POSTGRES_DATABASE=$(get_ssm_parameter "PostgresDatabase")
  DOCKER_REGISTRY=$(get_ssm_parameter "DockerRegistry")

  GIT_REPOSITORY_PATH=/home/ubuntu/rocket-analytics
  COMPOSE_FILE="${GIT_REPOSITORY_PATH}/docker-compose.yml"
  COMPOSE_FILE_PROD="${GIT_REPOSITORY_PATH}/docker-compose-prod.yml"
  ENV_FILE="${GIT_REPOSITORY_PATH}/.env"

  # Install and start the application
  install_application
  create_postgres_superuser_secret
  docker compose -f $COMPOSE_FILE -f $COMPOSE_FILE_PROD up -d --no-build

  # This script needs to be executed only once when server is created
  rm $0
}

install_docker () {
  DEBIAN_FRONTEND=noninteractive apt-get -y update
  DEBIAN_FRONTEND=noninteractive apt-get -y install \
    ca-certificates \
    curl \
    gnupg

  install -m 0755 -d /etc/apt/keyrings
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \
    gpg --dearmor -o /etc/apt/keyrings/docker.gpg

  echo \
    "deb [arch=$(dpkg --print-architecture)" \
    "signed-by=/etc/apt/keyrings/docker.gpg]" \
    "https://download.docker.com/linux/ubuntu" \
    "$(. /etc/os-release && echo $VERSION_CODENAME) stable" | \
    tee /etc/apt/sources.list.d/docker.list > /dev/null

  DEBIAN_FRONTEND=noninteractive apt-get -y update
  DEBIAN_FRONTEND=noninteractive apt-get -y install \
    docker-ce \
    docker-ce-cli \
    containerd.io \
    docker-buildx-plugin \
    docker-compose-plugin
}

install_application () {
  # Install software packages
  DEBIAN_FRONTEND=noninteractive apt-get -y update
  DEBIAN_FRONTEND=noninteractive apt-get -y install git jq
  install_docker

  # Clone git repository to get Docker Compose file
  git clone $GIT_REPOSITORY $GIT_REPOSITORY_PATH
  git -C $GIT_REPOSITORY_PATH checkout $GIT_BRANCH

  # Create and populate '.env' file for Docker Compose
  touch $ENV_FILE && chmod 600 $ENV_FILE
  echo "POSTGRES_DATABASE=$POSTGRES_DATABASE" | tee -a $ENV_FILE
  echo "DOCKER_REGISTRY=$DOCKER_REGISTRY" | tee -a $ENV_FILE
  echo "AWS_REGION=$REGION" | tee -a $ENV_FILE

  mount_db_volume

  # Pull Docker images
  aws ecr get-login-password --region $REGION | \
    docker login --username AWS --password-stdin $DOCKER_REGISTRY
  docker compose -f $COMPOSE_FILE -f $COMPOSE_FILE_PROD pull
}

create_postgres_superuser_secret() {
  # Disable trace so that secrets don't show up in log files
  set +x

  local postgres_superuser_secret
  local username
  local password
  local postgres_username_file
  local postgres_password_file

  postgres_superuser_secret=$(aws secretsmanager get-secret-value \
    --secret-id PostgresSuperuser --region $REGION --query SecretString \
    --output text)

  username=$(echo $postgres_superuser_secret | jq -r .username)
  password=$(echo $postgres_superuser_secret | jq -r .password)

  postgres_username_file="${GIT_REPOSITORY_PATH}/postgres_username.txt"
  postgres_password_file="${GIT_REPOSITORY_PATH}/postgres_password.txt"

  touch $postgres_username_file && chmod 600 $postgres_username_file
  touch $postgres_password_file && chmod 600 $postgres_password_file

  echo $username > $postgres_username_file
  echo $password > $postgres_password_file

  # Secret stuff is done, trace can be enabled
  set -x
}

get_db_volume_name () {
  id_without_hyphen=$(echo "$DB_VOLUME_ID" | tr -d "-")
  lsblk -p -o NAME,SERIAL | awk -v id=$id_without_hyphen '$2 == id {print $1}'
}

# $1: Parameter name
get_ssm_parameter () {
  echo $(aws ssm get-parameter --name $1 --region $REGION \
    --query 'Parameter.Value' --output text)
}

db_volume_is_formatted () {
  filesystem=$(lsblk -p -o NAME,FSTYPE | \
    awk -v name=$(get_db_volume_name) '$1 == name {print $2}')
  if [ "$filesystem" = "xfs" ]; then
    true
  else
    false
  fi
}

mount_db_volume () {
  if db_volume_is_formatted; then
    echo "Database EBS volume ($(get_db_volume_name)) has already been" \
      "formatted."
  else
    echo "Database EBS volume ($(get_db_volume_name)) is not formatted," \
      "formatting to XFS."
    mkfs -t xfs $(get_db_volume_name)
  fi
  mkdir /data
  mount $(get_db_volume_name) /data
}

main
